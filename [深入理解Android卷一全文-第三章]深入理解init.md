<div> <p><span><strong>由于《深入理解Android 卷一》和《深入理解Android卷二》不再出版，而知识的传播不应该因为纸质媒介的问题而中断，所以我将在CSDN博客中全文转发这两本书的全部内容。</strong></span></p><p><br /></p><h1><br /></h1><h1>第3章  深入理解init</h1><p>本章主要内容</p><p>·  深入分析init。</p><p>本章涉及的源代码文件名及位置</p><p>下面是本章分析的源码文件名及其位置。</p><p>·  init.c</p><p>system/core/init/init.c</p><p>·  parser.c</p><p>system/core/init/parser.c</p><p>·  builtins.c</p><p>system/core/init/builtins.c</p><p>·  keywords.h</p><p>system/core/init/keywords/h</p><p>·  init.rc</p><p>system/core/rootdir/init.rc</p><p>·  properties_service.c</p><p>system/core/init/properties_service.c</p><p>·  libc_init_dynamic.c</p><p>bionic/libc/bionic/libc_init_common.c</p><p>·  libc_init_common.c</p><p>bionic/libc/bionic/libc_init_common.c</p><p>·  properties.c</p><p>system/core/libcutils/properties.c</p><h2>3.1  概述</h2><p> init是一个进程，确切地说，它是Linux系统中用户空间的第一个进程。由于Android是基于Linux内核的，所以init也是Android系统中用户空间的第一个进程，它的进程号是1。作为天字第一号的进程，init被赋予了很多极其重要的工作职责，本章将关注其中两个比较重要的职责：</p><p>·  init进程负责创建系统中的几个关键进程，尤其是下一章要介绍的Zygote，它更是Java世界的开创者。那么，init进程是如何创建Zygote的呢？</p><p>·  Android系统有很多属性，于是init就提供了一个property service（属性服务）来管理它们。那么这个属性服务是怎么工作的呢？</p><p>如上所述，本章将通过下面两方面内容来分析init：</p><p>·  init如何创建zygote。</p><p>·  init的属性服务是如何工作的。</p><p> </p><h2>3.2  init分析</h2><p>init进程的入口函数是main，它的代码如下所示：</p><p>[--&gt;init.c]</p><div><p>int main(int argc, char **argv)</p><p>{</p><p>    intdevice_fd = -1;</p><p>    intproperty_set_fd = -1;</p><p>    intsignal_recv_fd = -1;</p><p>    intkeychord_fd = -1;</p><p>    int fd_count;</p><p>    ints[2];</p><p>    intfd;</p><p>    structsigaction act;</p><p>    chartmp[PROP_VALUE_MAX];</p><p>    structpollfd ufds[4];</p><p>    char*tmpdev;</p><p>    char*debuggable;</p><p>    </p><p>   //设置子进程退出的信号处理函数，该函数为sigchld_handler。</p><p>   act.sa_handler = sigchld_handler;</p><p>    act.sa_flags= SA_NOCLDSTOP;</p><p>   act.sa_mask = 0;</p><p>   act.sa_restorer = NULL;</p><p>   sigaction(SIGCHLD, &amp;act, 0);</p><p>   </p><p>   ......//创建一些文件夹，并挂载设备，这些是和Linux相关的，不拟做过多讨论。</p><p>   mkdir("/dev/socket", 0755);</p><p>   mount("devpts", "/dev/pts", "devpts", 0,NULL);</p><p>   mount("proc", "/proc", "proc", 0, NULL);</p><p>   mount("sysfs", "/sys", "sysfs", 0, NULL);</p><p> </p><p>    //重定向标准输入/输出/错误输出到/dev/_null_。</p><p>open_devnull_stdio();</p><p>/*</p><p>设置init的日志输出设备为/dev/__kmsg__，不过该文件打开后，会立即被unlink了,</p><p>这样，其他进程就无法打开这个文件读取日志信息了。</p><p>*/</p><p>   log_init();</p><p>    </p><p>   //上面涉及很多和Linux系统相关的知识，不熟悉的读者可自行研究，它们不影响我们的分析</p><p>   //解析init.rc配置文件</p><p>   parse_config_file("/init.rc");</p><p> </p><p>    ......</p><p>    //下面这个函数通过读取/proc/cpuinfo得到机器的Hardware名，我的HTCG7手机为bravo。</p><p>   get_hardware_name();</p><p>snprintf(tmp,sizeof(tmp), "/init.%s.rc", hardware);</p><p>//解析这个和机器相关的配置文件，我的G7手机对应文件为init.bravo.rc。</p><p>   parse_config_file(tmp);</p><p> </p><p>/*</p><p>解析完上述两个配置文件后，会得到一系列的Action（动作），下面两句代码将执行那些处于</p><p>early-init阶段的Action。init将动作执行的时间划分为四个阶段：early-init、init、</p><p>early-boot、boot。由于有些动作必须在其他动作完成后才能执行，所以就有了先后之分。哪些</p><p>动作属于哪个阶段由配置文件决定。后面会介绍配置文件的相关知识。</p><p>*/</p><p>   action_for_each_trigger("early-init", action_add_queue_tail);</p><p>   drain_action_queue();</p><p> </p><p>/*</p><p>创建利用Uevent和Linux内核交互的socket。关于Uevent的知识，第9章中对</p><p>Vold进行分析时会做介绍。</p><p>    */</p><p>   device_fd = device_init();</p><p>    //初始化和属性相关的资源</p><p>property_init();</p><p>//初始化/dev/keychord设备，这和调试有关，本书不讨论它的用法。读者可以自行研究，</p><p>//内容比较简单。</p><p>   keychord_fd = open_keychord();</p><p> </p><p>    ......</p><p>/*</p><p>  INIT_IMAGE_FILE定义为”/initlogo.rle”，下面这个函数将加载这个文件作为系统的开机</p><p> 画面，注意，它不是开机动画控制程序bootanimation加载的开机动画文件。</p><p>*/</p><p>if(load_565rle_image(INIT_IMAGE_FILE) ) {</p><p>   /*</p><p>如果加载initlogo.rle文件失败（可能是没有这个文件），则会打开/dev/ty0设备，并</p><p>输出”ANDROID”的字样作为开机画面。在模拟器上看到的开机画面就是它。</p><p>*/</p><p>      ......</p><p>      }</p><p>   }</p><p> </p><p>    if(qemu[0])</p><p>       import_kernel_cmdline(1); </p><p>   ......</p><p>//调用property_set函数设置属性项，一个属性项包括属性名和属性值。</p><p>   property_set("ro.bootloader", bootloader[0] ? bootloader :"unknown");</p><p> </p><p>    ......//执行位于init阶段的动作</p><p>   action_for_each_trigger("init", action_add_queue_tail);</p><p>   drain_action_queue();</p><p> </p><p>    //启动属性服务</p><p>   property_set_fd = start_property_service();</p><p> </p><p>/*</p><p>调用socketpair函数创建两个已经connect好的socket。socketpair是Linux的系统调用,</p><p>不熟悉的读者可以利用man socketpair查询相关信息。后面就会知道它们的用处了。</p><p>*/</p><p>    if(socketpair(AF_UNIX, SOCK_STREAM, 0, s) == 0) {</p><p>       signal_fd = s[0];</p><p>       signal_recv_fd = s[1];</p><p>        ......</p><p>    }</p><p> </p><p>    ......</p><p> </p><p>    //执行配置文件中early-boot和boot阶段的动作。</p><p>   action_for_each_trigger("early-boot", action_add_queue_tail);</p><p>   action_for_each_trigger("boot", action_add_queue_tail);</p><p>   drain_action_queue();</p><p>......     </p><p>    </p><p>//init关注来自四个方面的事情。</p><p>    ufds[0].fd= device_fd;//device_fd用于监听来自内核的Uevent事件</p><p>   ufds[0].events = POLLIN;</p><p>   ufds[1].fd = property_set_fd;//property_set_fd用于监听来自属性服务器的事件</p><p>ufds[1].events= POLLIN;</p><p>//signal_recv_fd由socketpair创建，它的事件来自另外一个socket。</p><p>   ufds[2].fd = signal_recv_fd;</p><p>   ufds[2].events = POLLIN;</p><p>   fd_count = 3;</p><p>if(keychord_fd &gt; 0) {</p><p>   //如果keychord设备初始化成功，则init也会关注来自这个设备的事件。</p><p>       ufds[3].fd = keychord_fd;</p><p>       ufds[3].events = POLLIN;</p><p>       fd_count++;</p><p>}</p><p>......</p><p> </p><p>#if BOOTCHART</p><p>    ......//与Boot char相关，不做讨论了。</p><p>/*</p><p>Boot chart是一个小工具，它能对系统的性能进行分析，并生成系统启动过程的图表，</p><p>以提供一些有价值的信息，而这些信息最大的用处就是帮助提升系统的启动速度。</p><p>    */</p><p>#endif</p><p>  for(;;) {</p><p>        //从此init将进入一个无限循环。</p><p>       int nr, i, timeout = -1;</p><p> </p><p>       for (i = 0; i &lt; fd_count; i++)</p><p>           ufds[i].revents = 0;</p><p>        </p><p>        //在循环中执行动作</p><p>       drain_action_queue();</p><p>       restart_processes(); //重启那些已经死去的进程</p><p>......</p><p>#if BOOTCHART</p><p>        ...... // Boot Chart相关</p><p>#endif</p><p>        //调用poll等待一些事情的发生</p><p>        nr= poll(ufds, fd_count, timeout);</p><p>       ......</p><p>       //ufds[2]保存的是signal_recv_fd，用于接收来自socket的消息。</p><p>        if(ufds[2].revents == POLLIN) {</p><p>           //有一个子进程去世，init要处理这个事情</p><p>            read(signal_recv_fd, tmp, sizeof(tmp));</p><p>           while (!wait_for_one_process(0))</p><p>               ;</p><p>           continue;</p><p>        }</p><p> </p><p>        if(ufds[0].revents == POLLIN)</p><p>           handle_device_fd(device_fd);//处理Uevent事件</p><p>        if(ufds[1].revents == POLLIN)</p><p>           handle_property_set_fd(property_set_fd);//处理属性服务的事件。</p><p>        if(ufds[3].revents == POLLIN)</p><p>           handle_keychord(keychord_fd);//处理keychord事件。</p><p>    }</p><p> </p><p>    return0;</p><p>}</p></div><p>从上面的代码中可知，init的工作任务还是很重的。上面的代码虽已省略了不少行，可结果还是很长，不过从本章要分析的两个知识点来看，可将init的工作流程精简为以下四点：</p><p>·  解析两个配置文件，其中，将分析对init.rc文件的解析。</p><p>·  执行各个阶段的动作，创建Zygote的工作就是在其中的某个阶段完成的。</p><p>·  调用property_init初始化属性相关的资源，并且通过property_start_service启动属性服务。</p><p>·  init进入一个无限循环，并且等待一些事情的发生。重点关注init如何处理来自socket和来自属性服务器相关的事情。</p><div><p>精简工作流程，是以后分析代码时常用的方法。读者在分析代码的过程中，也可使用这种方法。</p></div><h3>3.2.1  解析配置文件</h3><p>根据上面的代码可知，在init中会解析两个配置文件，其中一个是系统配置文件init.rc，另外一个是和硬件平台相关的配置文件。以HTC G7手机为例，这个配置文件名为init.bravo.rc，其中bravo是硬件平台的名称。对这两个配置文件进行解析，调用的是同一个parse_config_file函数。下面就来看这个函数，在分析过程中以init.rc为主。</p><p>[--&gt;parser.c]</p><div><p>int parse_config_file(const char *fn)</p><p>{</p><p>char *data;</p><p>data = read_file(fn, 0);//读取配置文件的内容，这个文件是init.rc。</p><p>if (!data) return -1;</p><p>parse_config(fn,data); //调用parse_config做真正的解析</p><p>return 0;</p><p>}</p></div><p>读取完文件的内容后，将调用parse_config进行解析，这个函数的代码如下所示：</p><p>[--&gt;parser.c]</p><div><p>static void parse_config(const char *fn, char*s)</p><p>{</p><p>struct parse_state state;</p><p>char *args[SVC_MAXARGS];</p><p>int nargs;</p><p> </p><p>nargs = 0;</p><p>state.filename = fn;</p><p>state.line = 1;</p><p>state.ptr = s;</p><p>state.nexttoken = 0;</p><p>state.parse_line = parse_line_no_op; //设置解析函数，不同的内容用不同的解析函数</p><p>for (;;) {</p><p>    switch(next_token(&amp;state)) {</p><p>      case T_EOF:</p><p>           state.parse_line(&amp;state, 0, 0);</p><p>           return;</p><p>      caseT_NEWLINE:</p><p>           if (nargs) {</p><p>              //得到关键字的类型</p><p>               int kw = lookup_keyword(args[0]);</p><p>               if (kw_is(kw, SECTION)) { //判断关键字类型是不是SECTION。</p><p>                    state.parse_line(&amp;state,0, 0);</p><p>                   parse_new_section(&amp;state,kw, nargs, args);//解析这个SECTION。</p><p>               } else {</p><p>                   state.parse_line(&amp;state, nargs, args);</p><p>               }</p><p>               nargs = 0;</p><p>           }</p><p>           break;</p><p>       case T_TEXT:</p><p>          ......</p><p>           break;</p><p>        }</p><p>    }</p><p>}</p></div><p>上面就是parse_config函数，代码虽短，实际却比较复杂。从整体来说，parse_config首先会找到配置文件的一个section，然后针对不同的 section使用不同的解析函数来解析。那么，什么是section呢？这和init.rc文件的组织结构有关。先不必急着去看init.rc，还是先到代码中去寻找答案。</p><h4>1. 关键字定义</h4><p>keywords.h这个文件定义了init中使用的关键字，它的用法很有意思，先来看这个文件，代码如下所示：</p><p>[--&gt;keywords.h]</p><div><p>#ifndef KEYWORD //如果没有定义KEYWORD宏，则走下面的分支</p><p>......//声明一些函数，这些函数就是前面所说Action的执行函数。</p><p>int do_class_start(int nargs, char **args);</p><p>int do_class_stop(int nargs, char **args);</p><p>......</p><p>int do_restart(int nargs, char **args);</p><p>...... </p><p>#define __MAKE_KEYWORD_ENUM__  //定义一个宏</p><p>/*</p><p>定义KEYWORD宏，虽然有四个参数，不过这里只用第一个，其中K_##symbol中的##表示连接</p><p>的意思，即最后得到的值为K_symbol。symbol其实就是init.rc中的关键字</p><p>*/</p><p>#define KEYWORD(symbol, flags, nargs, func)K_##symbol,</p><p>enum { //定义一个枚举，这个枚举定义了各个关键字的枚举值。</p><p>   K_UNKNOWN, </p><p>#endif</p><p>......</p><p>//根据上面KEYWORD的定义，这里将得到一个枚举值K_class,</p><p>   KEYWORD(class,       OPTION,  0, 0) </p><p>   KEYWORD(class_start, COMMAND, 1, do_class_start)//K_class_start,</p><p>KEYWORD(class_stop,  COMMAND, 1, do_class_stop)//K_class_stop,</p><p>KEYWORD(on,          SECTION, 0, 0)//K_on，</p><p>   KEYWORD(oneshot,     OPTION,  0, 0)</p><p>   KEYWORD(onrestart,   OPTION,  0, 0)</p><p>   KEYWORD(restart,     COMMAND, 1,do_restart)</p><p>   KEYWORD(service,     SECTION, 0,0)</p><p>    ......</p><p>   KEYWORD(socket,      OPTION,  0, 0)</p><p>   KEYWORD(start,       COMMAND, 1,do_start)</p><p>   KEYWORD(stop,        COMMAND, 1,do_stop)</p><p>    ......</p><p>#ifdef __MAKE_KEYWORD_ENUM__</p><p>   KEYWORD_COUNT,</p><p>};</p><p>#undef __MAKE_KEYWORD_ENUM__</p><p>#undef KEYWORD //取消KEYWORD宏定义</p><p>#endif</p></div><p>keywords.h好像没什么奇特，不过是个简单的头文件。为什么说它的用法很有意思呢？来看代码中是如何使用它的，如下所示：</p><p>[--&gt;parser.c]</p><div><p>......//parser.c中将包含keywords.h头文件，而且还不只一次！！</p><p>//第一次包含keywords.h，根据keywords.h的代码，我们首先会得到一个枚举定义</p><p>#include "keywords.h" </p><p>/*</p><p>重新定义KEYWORD宏，这回四个参数全用上了，看起来好像是一个结构体。其中#symbol表示</p><p>一个字符串，其值为“symbol”。</p><p>*/</p><p>#define KEYWORD(symbol, flags, nargs, func) \</p><p>    [K_##symbol ] = { #symbol, func, nargs + 1, flags, }, </p><p> </p><p>//定义一个结构体keyword_info数组，它用来描述关键字的一些属性，请注意里面的注释内容。</p><p>struct {</p><p>    constchar *name;  //关键字的名。</p><p>    int(*func)(int nargs, char **args);//对应关键字的处理函数。</p><p>unsignedchar nargs;//参数个数，每个关键字的参数个数是固定的。</p><p>//关键字的属性，有三种属性，COMMAND、OPTION和SECTION。其中COMMAND有对应的处理函数</p><p>   unsigned char flags; </p><p>} keyword_info[KEYWORD_COUNT] = {</p><p>[ K_UNKNOWN ] = { "unknown", 0, 0, 0},</p><p>/*</p><p>第二次包含keywords.h，由于已经重新定了KEYWORD宏，所以以前那些作为枚举值的关键字</p><p>现在变成keyword_info数组的索引了。</p><p>*/</p><p>#include "keywords.h"    </p><p>};</p><p>#undef KEYWORD</p><p> </p><p>//一些辅助宏，帮助我们快速操作keyword_info中的内容。</p><p>#define kw_is(kw, type) (keyword_info[kw].flags&amp; (type))</p><p>#define kw_name(kw) (keyword_info[kw].name)</p><p>#define kw_func(kw) (keyword_info[kw].func)</p><p>#define kw_nargs(kw) (keyword_info[kw].nargs)</p></div><p>现在领略了keywords.h的神奇之处了吧？原来它干了两件事情：</p><p>·  第一次包含keyworks.h时，它声明了一些诸如do_classstart这样的函数，另外还定义了一个枚举，枚举值为K_class，K_mkdir等关键字。</p><p>·  第二次包含keywords.h后，得到了一个keyword_info结构体数组，这个keyword_info结构体数组以前面定义的枚举值为索引，存储对应的关键字信息，这些信息包括关键字名、处理函数、处理函数的参数个数，以及属性。</p><p>目前，关键字信息中最重要的就是symbol和flags了。什么样的关键字被认为是section呢？根据keywords.h的定义，symbol为下面两个的关键字表示section：</p><div><p>KEYWORD(on,          SECTION, 0, 0)</p><p>KEYWORD(service,     SECTION, 0, 0)</p></div><p>有了上面的知识，再来看配置文件init.rc的内容。</p><h4>2. init.rc的解析</h4><p>init.rc的内容如下所示：（我们截取了部分内容，注意，其中的注释符号是#。）</p><p>[--&gt;init.rc]</p><div><p>on init  #根据上面的分析，on关键字标示一个section，对应的名字是”init”</p><p> ......  #下面所有的内容都属于这个section，直到下一个section开始时。</p><p> exportPATH /sbin:/system/sbin:/system/bin:/system/xbin</p><p> exportLD_LIBRARY_PATH /system/lib</p><p> exportANDROID_BOOTLOGO 1 #根据keywords.h的定义，export表示一个COMMAND</p><p>export ANDROID_ROOT /system</p><p> exportANDROID_ASSETS /system/app </p><p>...... #省略部分内容</p><p>on boot  #这是一个新的section，名为”boot”</p><p>   ifup lo#这是一个COMMAND</p><p>   hostname localhost</p><p>   domainname localdomain</p><p>    ......</p><p>   #class_start也是一个COMMAND，对应函数为do_class_start，很重要，切记。</p><p>    class_startdefault  </p><p>    ......</p><p>#下面这个section的意思是：待属性persist.service.adb.enable的值变为1后，</p><p>#需要执行对应的COMMAND，这个COMMAND是start adbd</p><p>     onproperty:persist.service.adb.enable=1</p><p>         start adbd //start是一个COMMAND</p><p>     on property:persist.service.adb.enable=0</p><p>         stopadbd</p><p>    ......</p><p>#service也是section的标示，对应section的名为“zygote“</p><p>service zygote /system/bin/app_process -Xzygote/system/bin –zygote        \</p><p> --start-system-server</p><p>    socketzygote stream 666  #socket关键字表示OPTION</p><p>   onrestart write /sys/android_power/request_state wake #onrestart也是OPTION</p><p>   onrestart write /sys/power/state on</p><p>   onrestart restart media</p><p>#一个section，名为”media”</p><p>service media /system/bin/mediaserver</p><p>    usermedia</p><p>    groupsystem audio camera graphics inet net_bt net_bt_admin net_raw</p><p>iopriort 4</p></div><p>从上面对init.rc的分析中可知：</p><p>·  一个section的内容从这个标示section的关键字开始，到下一个标示section的地方结束。</p><p>·  init.rc中出现了名为boot和init的section，这里的boot和init，就是前面介绍的动作执行四个阶段中的boot和init。也就是说，在boot阶段执行的动作都是由boot这个section定义的。</p><p>另外还可发现，zygote被放在了一个servicesection中。下面以zygote这个section为例，介绍service是如何解析的。</p><h3>3.2.2  解析service</h3><p>zygote对应的service section内容是：</p><p>[--&gt;init.rc::zygote]</p><div><p>service zygote /system/bin/app_process -Xzygote/system/bin –zygote \ --start-system-server</p><p>socketzygote stream 666  #socket是OPTION</p><p>#下面的onrestart是OPTION，而write和restart是COMMAND</p><p>    onrestartwrite /sys/android_power/request_state wake</p><p>   onrestart write /sys/power/state on</p><p>onrestartrestart media</p></div><p>解析section的入口函数是parse_new_section，它的代码如下所示：</p><p>[--&gt;parser.c]</p><div><p>void parse_new_section(struct parse_state*state, int kw,</p><p>                       int nargs, char **args)</p><p>{</p><p>   switch(kw) {</p><p>    caseK_service:  //解析service，用parse_service和parse_line_service</p><p>       state-&gt;context = parse_service(state, nargs, args);</p><p>        if(state-&gt;context) {</p><p>           state-&gt;parse_line = parse_line_service;</p><p>            return;</p><p>        }</p><p>       break;</p><p>    caseK_on: //解析on section</p><p>        ......//读者可以自己研究</p><p>       break;</p><p>    }</p><p>   state-&gt;parse_line = parse_line_no_op;</p><p>}</p></div><p>其中，service解析时，用到了parse_service和parse_line_service两个函数，在分别介绍它们之前，先看init是如何组织这个service的。</p><h4>1. service结构体</h4><p>init中使用了一个叫service的结构体来保存和service section相关的信息，不妨来看这个结构体，代码如下所示：</p><p>[--&gt;init.h::service结构体定义]</p><div><p>struct service {</p><p> //listnode是一个特殊的结构体，在内核代码中用得非常多，主要用来将结构体链接成一个</p><p>  //双向链表。init中有一个全局的service_list，专门用来保存解析配置文件后得到的service。</p><p>   struct listnode slist;  </p><p>    constchar *name; //service的名字，对应我们这个例子就是”zygote”。</p><p>    constchar *classname; //service所属class的名字，默认是”defult”</p><p>   unsigned flags;//service的属性</p><p>    pid_tpid;    //进程号</p><p>    time_ttime_started;   //上一次启动的时间</p><p>    time_ttime_crashed;  //上一次死亡的时间</p><p>    intnr_crashed;        //死亡次数</p><p>     uid_tuid;     //uid,gid相关</p><p>    gid_tgid;</p><p>    gid_tsupp_gids[NR_SVC_SUPP_GIDS];</p><p>    size_tnr_supp_gids;</p><p>   /*</p><p>有些service需要使用socket，下面这个socketinfo用来描述socket的相关信息。</p><p>我们的zygote也使用了socket，配置文件中的内容是socket zygote stream 666。</p><p>它表示将创建一个AF_STREAM类型的socket（其实就是TCP socket），该socket的名为“zygote”，</p><p>读写权限是666。</p><p>   */</p><p>structsocketinfo *sockets;  </p><p>//service一般运行在单独的一个进程中，envvars用来描述创建这个进程时所需的环境变量信息。</p><p>    structsvcenvinfo *envvars;  </p><p>   /*</p><p>  虽然关键字onrestart标示一个OPTION，可是这个OPTION后面一般跟着COMMAND，</p><p> 下面这个action结构体可用来存储command信息，马上就会分析到它。</p><p>*/</p><p>    structaction onrestart; </p><p>    </p><p>    //和keychord相关的内容</p><p>    int*keycodes;</p><p>    intnkeycodes;</p><p>    intkeychord_id;</p><p>    //io优先级设置</p><p>    intioprio_class;</p><p>    intioprio_pri;</p><p>    //参数个数</p><p>    intnargs;</p><p>    //用于存储参数</p><p>    char*args[1];</p><p>};  </p></div><p>我们现在已了解的service的结构体，相对来说还算是清晰易懂的。而zygote中的那三个onrestart该怎么表示呢？请看service中使用的这个action结构体：</p><p>[--&gt;init.h::action结构体定义]</p><div><p>struct action {</p><p>/*</p><p>一个action结构体可存放在三个双向链表中，其中alist用于存储所有action，</p><p>qlist用于链接那些等待执行的action，tlist用于链接那些待某些条件满足后</p><p>就需要执行的action。</p><p>*/</p><p>    structlistnode alist;</p><p>   structlistnode qlist;</p><p>    structlistnode tlist;</p><p> </p><p>   unsigned hash;</p><p>    constchar *name;</p><p>    </p><p>   //这个OPTION对应的COMMAND链表，以zygote为例，它有三个onrestart option，所以</p><p>  //它对应会创建三个command结构体。</p><p>    structlistnode commands;</p><p>    structcommand *current;</p><p>};</p></div><p>了解了上面的知识后，你是否能猜到parse_service和parse_line_service的作用了呢？马上就来看它们。</p><h4>2. parse_service</h4><p>parse_service的代码如下所示：</p><p>[--&gt;parser.c]</p><div><p>static void *parse_service(struct parse_state*state, int nargs, char **args)</p><p>{</p><p>    structservice *svc; //声明一个service结构体</p><p>    ......</p><p>    //init维护了一个全局的service链表，先判断是否已经有同名的service了。</p><p>    svc =service_find_by_name(args[1]);</p><p>    if(svc) {</p><p>       ......  //如果有同名的service，则不能继续后面的操作。</p><p>       return 0;</p><p>    }</p><p>    </p><p>nargs-= 2;</p><p>    svc =calloc(1, sizeof(*svc) + sizeof(char*) * nargs);</p><p>    ......</p><p>   svc-&gt;name = args[1];</p><p>svc-&gt;classname= "default";//设置classname为”default”，这个很关键！</p><p>   memcpy(svc-&gt;args, args + 2, sizeof(char*) * nargs);</p><p>   svc-&gt;args[nargs] = 0;</p><p>   svc-&gt;nargs = nargs;</p><p>svc-&gt;onrestart.name= "onrestart";</p><p> </p><p>   list_init(&amp;svc-&gt;onrestart.commands);</p><p>    //把zygote这个service加到全局链表service_list中。</p><p>   list_add_tail(&amp;service_list, &amp;svc-&gt;slist);</p><p>    returnsvc;</p><p>}</p></div><p>parse_service函数只是搭建了一个service的架子，具体的内容尚需由后面的解析函数来填充。来看service的另外一个解析函数parse_line_service。</p><h4>3. parse_line_service</h4><p>parse_line_service的代码如下所示：</p><p>[--&gt;parser.c]</p><div><p>static void parse_line_service(structparse_state *state, int nargs, </p><p>char **args)</p><p>{</p><p>    structservice *svc = state-&gt;context;</p><p>    structcommand *cmd;</p><p>    int i,kw, kw_nargs;</p><p>    ......</p><p>   svc-&gt;ioprio_class = IoSchedClass_NONE;</p><p>    //其实还是根据关键字来做各种处理。</p><p>    kw =lookup_keyword(args[0]);</p><p>    switch(kw) {</p><p>    caseK_capability:</p><p>       break;</p><p>    caseK_class:</p><p>        if(nargs != 2) {</p><p>           ......</p><p>        }else {</p><p>           svc-&gt;classname = args[1];</p><p>        }</p><p>       break;</p><p>    ......</p><p>caseK_oneshot:</p><p>   /*</p><p>这是service的属性，它一共有五个属性，分别为：</p><p>SVC_DISABLED：不随class自动启动。下面将会看到class的作用。</p><p>SVC_ONESHOT：退出后不需要重启，也就是这个service只启动一次就可以了。</p><p>SVC_RUNNING：正在运行，这是service的状态。</p><p>SVC_RESTARTING：等待重启，这也是service的状态。</p><p>SVC_CONSOLE：该service需要使用控制台 。</p><p>SVC_CRITICAL：如果在规定时间内该service不断重启，则系统会重启并进入恢复模式。</p><p>zygote没有使用任何属性，这表明它：会随着class的处理自动启动；</p><p>退出后会由init重启；不使用控制台；即使不断重启也不会导致系统进入恢复模式。</p><p>       */</p><p>       svc-&gt;flags |= SVC_ONESHOT;</p><p>       break;</p><p>    caseK_onrestart: //根据onrestart的内容，填充action结构体的内容</p><p>       nargs--;</p><p>       args++;</p><p>        kw= lookup_keyword(args[0]);</p><p>        ......</p><p>        //创建command结构体</p><p>       cmd = malloc(sizeof(*cmd) + sizeof(char*) * nargs);</p><p>       cmd-&gt;func = kw_func(kw);</p><p>       cmd-&gt;nargs = nargs;</p><p>       memcpy(cmd-&gt;args, args, sizeof(char*) * nargs);</p><p>        //把新建的command加入到双向链表中。</p><p>       list_add_tail(&amp;svc-&gt;onrestart.commands, &amp;cmd-&gt;clist);</p><p>       break;</p><p>    ......</p><p>    caseK_socket: { //创建socket相关信息</p><p>       struct socketinfo *si;</p><p>        ......</p><p>        si= calloc(1, sizeof(*si));</p><p>        if(!si) {</p><p>           parse_error(state, "out of memory\n");</p><p>           break;</p><p>        }</p><p>       si-&gt;name = args[1]; //socket的名字</p><p>       si-&gt;type = args[2]; //socket的类型</p><p>       si-&gt;perm = strtoul(args[3], 0, 8); //socket的读写权限</p><p>        if(nargs &gt; 4)</p><p>           si-&gt;uid = decode_uid(args[4]);</p><p>        if(nargs &gt; 5)</p><p>           si-&gt;gid = decode_uid(args[5]);</p><p>       si-&gt;next = svc-&gt;sockets;</p><p>       svc-&gt;sockets = si;</p><p>       break;</p><p>    }</p><p>    ......</p><p>   default:</p><p>       parse_error(state, "invalid option '%s'\n", args[0]);</p><p>    }</p><p>}</p></div><p>parse_line_service将根据配置文件的内容填充service结构体，那么，zygote解析完后会得到什么呢？图3-1表示了zygote解析后的结果：</p><p><img src="images/Center.jpg" alt="Center.jpg" /><br /></p><p>图3-1  zygote解析结果示意图</p><p>从上图中可知：</p><p>·  service_list链表将解析后的service全部链接到了一起，并且是一个双向链表，前向节点用prev表示，后向节点用next表示。</p><p>·  socketinfo也是一个双向链表，因为zygote只有一个socket，所以画了一个虚框socket做为链表的示范。</p><p>·  onrestart通过commands指向一个commands链表，zygote有三个commands。</p><p>zygote这个service解析完了，现在就是“万事俱备，只欠东风”了。接下来要了解的是，init是如何控制service的。</p><h3>3.2.3  init控制service</h3><p>先看service是如何启动的。</p><h4>1．启动zygote</h4><p>init.rc中有这样一句话：</p><div><p>#class_start是一个COMMAND，对应的函数为do_class_start，很重要，切记。</p><p> class_startdefault</p></div><p>class_start标示一个COMMAND，对应的处理函数为do_class_start，它位于boot section的范围内。为什么说它很重要呢？</p><p>还记得init进程中的四个执行阶段吗？当init进程执行到下面几句话时，do_class_start就会被执行了。</p><div><p>//将bootsection节的command加入到执行队列</p><p>action_for_each_trigger("boot",action_add_queue_tail);</p><p>//执行队列里的命令，class可是一个COMMAND，所以它对应的do_class_start会被执行。</p><p>drain_action_queue(); </p></div><p>下面来看do_class_start函数：</p><p>[--&gt;builtins.c]</p><div><p>int do_class_start(int nargs, char **args)</p><p>{</p><p>/*</p><p>args为do_class_start的参数，init.rc中只有一个参数，就是default。</p><p>下面这个函数将从service_list中寻找classname为”default”的service，然后</p><p>调用service_start_if_not_disabled函数。现在读者明白了service结构体中</p><p>classname的作用了吗？</p><p>*/</p><p>service_for_each_class(args[1],service_start_if_not_disabled);</p><p>return 0;</p><p>}</p></div><p>我们已经知道，zygote这个service的classname的值就是“default”，所以会针对这个service调用service_start_if_not_disabled，这个函数的代码是：</p><p>[--&gt;parser.c]</p><div><p>static void service_start_if_not_disabled(structservice *svc)</p><p>{</p><p>if (!(svc-&gt;flags &amp; SVC_DISABLED)) {</p><p>     service_start(svc,NULL); //zygote可没有设置SVC_DISABLED</p><p> }</p><p>}</p></div><p>service_start函数的代码如下所示：</p><p>[--&gt;init.c]</p><div><p>void service_start(struct service *svc, constchar *dynamic_args)</p><p>{</p><p>    structstat s;</p><p>    pid_tpid;</p><p>    intneeds_console;</p><p>    int n;</p><p> </p><p>   svc-&gt;flags &amp;= (~(SVC_DISABLED|SVC_RESTARTING));</p><p>   svc-&gt;time_started = 0;</p><p>    </p><p>    if(svc-&gt;flags &amp; SVC_RUNNING) {</p><p>       return;//如果这个service已在运行，则不用处理</p><p>    }</p><p>  /*</p><p>service一般运行于另外一个进程中，这个进程也是init的子进程，所以启动service前需要判断</p><p>对应的可执行文件是否存在，zygote对应的可执行文件是/system/bin/app_process</p><p>*/</p><p>    if(stat(svc-&gt;args[0], &amp;s) != 0) {</p><p>      svc-&gt;flags |= SVC_DISABLED;</p><p>       return;</p><p>    }</p><p>    ......</p><p>   pid =fork(); //调用fork创建子进程</p><p>if(pid == 0) {</p><p>    //pid为零，我们在子进程中</p><p>       struct socketinfo *si;</p><p>       struct svcenvinfo *ei;</p><p>       char tmp[32];</p><p>       int fd, sz;</p><p>        </p><p>//得到属性存储空间的信息并加到环境变量中，后面在属性服务一节中会碰到使用它的地方。</p><p>       get_property_workspace(&amp;fd, &amp;sz);</p><p>       add_environment("ANDROID_PROPERTY_WORKSPACE", tmp);</p><p>        //添加环境变量信息</p><p>       for (ei = svc-&gt;envvars; ei; ei = ei-&gt;next)</p><p>           add_environment(ei-&gt;name, ei-&gt;value);</p><p>        //根据socketinfo创建socket</p><p>       for (si = svc-&gt;sockets; si; si = si-&gt;next) {</p><p>           int s = create_socket(si-&gt;name,</p><p>                                  !strcmp(si-&gt;type,"dgram") ? </p><p>                                  SOCK_DGRAM :SOCK_STREAM,</p><p>                                  si-&gt;perm,si-&gt;uid, si-&gt;gid);</p><p>           if (s &gt;= 0) {</p><p>               //在环境变量中添加socket信息。</p><p>                publish_socket(si-&gt;name, s);</p><p>           }</p><p>        }</p><p>       ......//设置uid，gid等</p><p>     setpgid(0, getpid());</p><p>       if(!dynamic_args) {</p><p>        /*</p><p>执行/system/bin/app_process，这样就进入到app_process的main函数中了。</p><p>fork、execve这两个函数都是Linux系统上常用的系统调用。</p><p>        */</p><p>            if (execve(svc-&gt;args[0], (char**)svc-&gt;args, (char**) ENV) &lt; 0) {</p><p>              ......</p><p>           }</p><p>        }else {</p><p>          ...... </p><p>    }</p><p> </p><p>   ......//父进程init的处理，设置service的信息，如启动时间、进程号，以及状态等。</p><p>   svc-&gt;time_started = gettime();</p><p>   svc-&gt;pid = pid;</p><p>   svc-&gt;flags |= SVC_RUNNING;</p><p>//每一个service都有一个属性，zygote的属性为init.svc.zygote，现在设置它的值为running</p><p>   notify_service_state(svc-&gt;name, "running");</p><p>}</p></div><p>原来，zygote是通过fork和execv共同创建的！但service结构中的那个onrestart好像没有派上用场，原因何在？</p><h4>2. 重启zygote</h4><p>根据名字，就可猜到onrestart应该是在zygote重启时用的。下面先看在zygote死后，它的父进程init会有什么动作：</p><p>[--&gt;init.c]</p><div><p>static void sigchld_handler(int s)</p><p>{  //当子进程退出时，init的这个信号处理函数会被调用</p><p>   write(signal_fd, &amp;s, 1); //往signal_fd write数据</p><p>}</p></div><p>signal_fd，就是在init中通过socketpair创建的两个socket中的一个，既然会往这个signal_fd中发送数据，那么另外一个socket就一定能接收到，这样就会导致init从poll函数中返回：</p><p>[--&gt;init.rc::main函数代码片断]</p><div><p> nr =poll(ufds, fd_count, timeout);</p><p> ......</p><p> if(ufds[2].revents == POLLIN) {</p><p>   read(signal_recv_fd, tmp, sizeof(tmp));</p><p>       while (!wait_for_one_process(0))//调用wait_for_one_process函数处理</p><p>         ;</p><p>       continue;</p><p> }</p><p> ......</p><p>//直接看这个wait_for_one_process函数：</p><p>static int wait_for_one_process(int block)</p><p>{</p><p>    pid_tpid;</p><p>    intstatus;</p><p>    structservice *svc;</p><p>    structsocketinfo *si;</p><p>    time_tnow;</p><p>    structlistnode *node;</p><p>    structcommand *cmd;</p><p> </p><p>while( (pid = waitpid(-1, &amp;status, block ? 0 : WNOHANG)) == -1 &amp;&amp; </p><p>errno == EINTR );</p><p>    if(pid &lt;= 0) return -1;</p><p>    //找到死掉的那个service，现在应该找到了代表zygote的那个service。</p><p>svc = service_find_by_pid(pid);</p><p>   ......</p><p> </p><p>if(!(svc-&gt;flags &amp; SVC_ONESHOT)) {</p><p>    //杀掉zygote创建的所有子进程，这就是zygote死后，Java世界崩溃的原因。</p><p>       kill(-pid, SIGKILL);</p><p>   }</p><p> </p><p>    //清理socket信息，不清楚的读者可以通过命令man 7 AF_UNIX查询一下相关知识。</p><p>    for(si = svc-&gt;sockets; si; si = si-&gt;next) {</p><p>       char tmp[128];</p><p>       snprintf(tmp, sizeof(tmp), ANDROID_SOCKET_DIR"/%s",si-&gt;name);</p><p>        unlink(tmp);</p><p>    }</p><p> </p><p>   svc-&gt;pid = 0;</p><p>   svc-&gt;flags &amp;= (~SVC_RUNNING);</p><p> </p><p>   if(svc-&gt;flags &amp; SVC_ONESHOT) {</p><p>       svc-&gt;flags |= SVC_DISABLED;</p><p>    }</p><p>   ......</p><p>now= gettime();</p><p>/*</p><p>如果设置了SVC_CRITICAL标示，则4分钟内该服务重启次数不能超过4次，否则</p><p>机器会重启进入recovery模式。根据init.rc的配置，只有servicemanager进程</p><p>享有此种待遇。</p><p>*/</p><p>    if(svc-&gt;flags &amp; SVC_CRITICAL) {</p><p>        if(svc-&gt;time_crashed + CRITICAL_CRASH_WINDOW &gt;= now) {</p><p>           if (++svc-&gt;nr_crashed &gt; CRITICAL_CRASH_THRESHOLD) {</p><p>              ......</p><p>               sync();</p><p>               __reboot(LINUX_REBOOT_MAGIC1,LINUX_REBOOT_MAGIC2,</p><p>                        LINUX_REBOOT_CMD_RESTART2, "recovery");</p><p>               return 0;</p><p>           }</p><p>        }else {</p><p>           svc-&gt;time_crashed = now;</p><p>           svc-&gt;nr_crashed = 1;</p><p>        }</p><p>    }</p><p> </p><p>   svc-&gt;flags |= SVC_RESTARTING;</p><p>//设置标示为SVC_RESTARTING,然后执行该service onrestart中的COMMAND，这些内容就</p><p>//非常简单了，读者可以自行学习。</p><p>   list_for_each(node, &amp;svc-&gt;onrestart.commands) {</p><p>       cmd = node_to_item(node, struct command, clist);</p><p>       cmd-&gt;func(cmd-&gt;nargs, cmd-&gt;args);</p><p>}</p><p>//设置init.svc.zygote的值为restarting。</p><p>   notify_service_state(svc-&gt;name, "restarting");</p><p>    return0;</p><p>}</p></div><p>通过上面的代码，可知道onrestart的作用了，但zygote本身又在哪里重启的呢？答案就在下面的代码中：</p><p>[--&gt;init.c::main函数代码片断]</p><div><p>for(;;) {</p><p>       int nr, i, timeout = -1;</p><p>       for (i = 0; i &lt; fd_count; i++)</p><p>           ufds[i].revents = 0;</p><p>       drain_action_queue(); //poll函数返回后，会进入下一轮的循环</p><p>       restart_processes(); //这里会重启所有flag标志为SVC_RESTARTING的service。</p><p>       ......</p><p>}</p></div><p>这样，zygote又回来了！</p><h3>3.2.4  属性服务</h3><p>我们知道，Windows平台上有一个叫注册表的东西。注册表可以存储一些类似key/value的键值对。一般而言，系统或某些应用程序会把自己的一些属性存储在注册表中，即使下次系统重启或应用程序重启，它还能够根据之前在注册表中设置的属性，进行相应的初始化工作。Android平台也提供了一个类型机制，可称之为属性服务（property service）。应用程序可通过这个属性机制，查询或设置属性。读者可以用adb shell登录到真机或模拟器上，然后用getprop命令查看当前系统中有哪些属性。即如我的HTC G7测试结果，如图3-2所示：（图中只显示了部分属性）</p><p><img src="images/Center.jpg" alt="Center.jpg" /><br /></p><p>图3-2  HTC G7属性示意图</p><p>这个属性服务是怎么实现的呢？下面来看代码，其中与init.c和属性服务有关的代码有下面两行：</p><div><p>property_init();</p><p>property_set_fd = start_property_service();</p></div><p>分别来看看它们。</p><h4>1. 属性服务初始化</h4><h5>（1）创建存储空间</h5><p>先看property_init函数，代码如下所示：</p><p>[--&gt;property_service.c]</p><div><p>void property_init(void)</p><p>{</p><p>init_property_area();//初始化属性存储区域</p><p>//加载default.prop文件</p><p>   load_properties_from_file(PROP_PATH_RAMDISK_DEFAULT);</p><p>}</p></div><p>在properyty_init函数中，先调用init_property_area函数，创建一块用于存储属性的存储区域，然后加载default.prop文件中的内容。再看init_property_area是如何工作的，它的代码如下所示：</p><p>[--&gt;property_service.c]</p><div><p>static int init_property_area(void)</p><p>{</p><p>   prop_area *pa;</p><p> </p><p>   if(pa_info_array)</p><p>       return -1;</p><p>/*</p><p>初始化存储空间，PA_SIZE是这块存储空间的总大小，为32768字节,pa_workspace</p><p>为workspace类型的结构体，下面是它的定义：</p><p>typedef struct {</p><p>    void *data;   //存储空间的起始地址</p><p>    size_tsize;  //存储空间的大小</p><p>    int fd;   //共享内存的文件描述符</p><p>} workspace;</p><p>init_workspace函数调用Android系统提供的ashmem_create_region函数创建一块</p><p>共享内存。关于共享内存的知识我们在第7章会接触，这里，只需把它当做一块普通的内存就</p><p>可以了。</p><p>    */</p><p>   if(init_workspace(&amp;pa_workspace, PA_SIZE))</p><p>       return -1;</p><p> </p><p>   fcntl(pa_workspace.fd, F_SETFD, FD_CLOEXEC);</p><p>   </p><p>//在32768个字节的存储空间中，有PA_INFO_START（1024）个字节用来存储头部信息</p><p>   pa_info_array = (void*) (((char*) pa_workspace.data) + PA_INFO_START);</p><p> </p><p>    pa =pa_workspace.data;</p><p>   memset(pa, 0, PA_SIZE);</p><p>   pa-&gt;magic = PROP_AREA_MAGIC;</p><p>   pa-&gt;version = PROP_AREA_VERSION;</p><p>//__system_property_area__这个变量由bionic libc库输出，有什么用呢？</p><p>       __system_property_area__ = pa; </p><p> </p><p>    return0;</p><p>}</p></div><p>上面的内容比较简单，不过最后的赋值语句可是大有来头。__system_property_area__是bionic libc库中输出的一个变量，为什么这里要给它赋值呢？</p><p>原来，虽然属性区域是由init进程创建，但Android系统希望其他进程也能读取这块内存里的东西。为做到这一点，它便做了以下两项工作：</p><p>·  把属性区域创建在共享内存上，而共享内存是可以跨进程的。这一点，已经在上面的代码中见到了，init_workspace函数内部将创建这个共享内存。</p><p>·  如何让其他进程知道这个共享内存呢？Android利用了gcc的constructor属性，这个属性指明了一个__libc_prenit函数，当bionic libc库被加载时，将自动调用这个__libc_prenit，这个函数内部就将完成共享内存到本地进程的映射工作。</p><h5>（2）客户端进程获取存储空间</h5><p>关于上面的内容，来看相关代码：</p><p>[--&gt;libc_init_dynamic.c]</p><div><p>//constructor属性指示加载器加载该库后，首先调用__libc_prenit函数。这一点和Windows上</p><p>//动态库的DllMain函数类似</p><p>void __attribute__((constructor))__libc_prenit(void);</p><p>void __libc_prenit(void)</p><p>{</p><p>    ......</p><p>     __libc_init_common(elfdata); //调用这个函数</p><p>    ......</p><p>}</p></div><p>__libc_init_common函数为：</p><p>[--&gt;libc_init_common.c]</p><div><p>void __libc_init_common(uintptr_t *elfdata)</p><p>{</p><p>   ......</p><p>   __system_properties_init();//初始化客户端的属性存储区域</p><p>}</p></div><p>[--&gt;system_properties.c]</p><div><p>int __system_properties_init(void)</p><p>{</p><p>   prop_area *pa;</p><p>    int s,fd;</p><p>   unsigned sz;</p><p>    char*env;</p><p> </p><p>.....</p><p>//还记得在启动zygote一节中提到的添加环境变量的地方吗？属性存储区域的相关信息</p><p>//就是在那儿添加的，这里需要取出来使用了。</p><p>    env =getenv("ANDROID_PROPERTY_WORKSPACE");</p><p>    //取出属性存储区域的文件描述符。关于共享内存的知识，第7章中将会进行介绍。</p><p>    fd =atoi(env);</p><p>    env =strchr(env, ',');</p><p>    if(!env) {</p><p>       return -1;</p><p>    }</p><p>    sz =atoi(env + 1);</p><p>//映射init创建的那块内存到本地进程空间，这样本地进程就可以使用这块共享内存了。</p><p>//注意，映射的时候指定了PROT_READ属性，所以客户端进程只能读属性，而不能设置属性。</p><p>    pa =mmap(0, sz, PROT_READ, MAP_SHARED, fd, 0);</p><p>    </p><p>    if(pa== MAP_FAILED) {</p><p>       return -1;</p><p>    }</p><p> </p><p>   if((pa-&gt;magic != PROP_AREA_MAGIC) || (pa-&gt;version !=PROP_AREA_VERSION)) {</p><p>       munmap(pa, sz);</p><p>       return -1;</p><p>    }</p><p> </p><p>   __system_property_area__ = pa;</p><p>    return0;</p><p>}</p></div><p>上面代码中很多地方和共享内存有关，在第7章中会对与共享内存有关问题进行介绍，读者也可先行学习有关共享内存的知识。</p><p>总之，通过这种方式，客户端进程可以直接读取属性空间，但没有权限设置属性。客户端进程又是如何设置属性呢？</p><h4>2. 启动属性服务器</h4><h5>（1）启动属性服务器</h5><p>init进程会启动一个属性服务器，而客户端只能通过和属性服务器交互才能设置属性。先来看属性服务器的内容，它由start_property_service函数启动，代码如下所示：</p><p>[--&gt;Property_servie.c]</p><div><p>int start_property_service(void)</p><p>{</p><p>    intfd;</p><p>   </p><p>   /*</p><p>       加载属性文件，其实就是解析这些文件中的属性，然后把它设置到属性空间中去。Android系统</p><p>      一共提供了四个存储属性的文件，它们分别是：</p><p>     #definePROP_PATH_RAMDISK_DEFAULT "/default.prop"</p><p>#define PROP_PATH_SYSTEM_BUILD     "/system/build.prop"</p><p>#define PROP_PATH_SYSTEM_DEFAULT   "/system/default.prop"</p><p>#define PROP_PATH_LOCAL_OVERRIDE   "/data/local.prop"</p><p>*/ </p><p>   </p><p>   load_properties_from_file(PROP_PATH_SYSTEM_BUILD);</p><p>   load_properties_from_file(PROP_PATH_SYSTEM_DEFAULT);</p><p>load_properties_from_file(PROP_PATH_LOCAL_OVERRIDE);</p><p>//有一些属性是需要保存到永久介质上的，这些属性文件则由下面这个函数加载，这些文件</p><p>//存储在/data/property目录下，并且这些文件的文件名必须以persist.开头。这个函数</p><p>//很简单，读者可自行研究。</p><p>    load_persistent_properties();</p><p>   //创建一个socket，用于IPC通信。</p><p>    fd =create_socket(PROP_SERVICE_NAME, SOCK_STREAM, 0666, 0, 0);</p><p>    if(fd&lt; 0) return -1;</p><p>   fcntl(fd, F_SETFD, FD_CLOEXEC);</p><p>   fcntl(fd, F_SETFL, O_NONBLOCK);</p><p>   listen(fd, 8);</p><p>    returnfd;</p><p>}</p></div><p>属性服务创建了一个用来接收请求的socket，可这个请求在哪里被处理呢？事实上，在init中的for循环那里已经进行相关处理了。</p><h5>（2）处理设置属性请求</h5><p>接收请求的地方是在init进程中，代码如下所示：</p><p>[--&gt;init.c::main函数片断]</p><div><p>if (ufds[1].revents == POLLIN)</p><p>           handle_property_set_fd(property_set_fd);</p></div><p>当属性服务器收到客户端请求时，init会调用handle_property_set_fd进行处理。这个函数的代码如下所示：</p><p>[--&gt;property_service.c]</p><div><p>void handle_property_set_fd(int fd)</p><p>{</p><p>   prop_msg msg;</p><p>    int s;</p><p>    int r;</p><p>    intres;</p><p>    structucred cr;</p><p>    structsockaddr_un addr;</p><p>   socklen_t addr_size = sizeof(addr);</p><p>   socklen_t cr_size = sizeof(cr);</p><p>    //先接收TCP连接</p><p>    if ((s= accept(fd, (struct sockaddr *) &amp;addr, &amp;addr_size)) &lt; 0) {</p><p>       return;</p><p>    }</p><p> </p><p>    //取出客户端进程的权限等属性。</p><p>    if(getsockopt(s, SOL_SOCKET, SO_PEERCRED, &amp;cr, &amp;cr_size) &lt; 0) {</p><p>        ......</p><p>       return;</p><p>    }</p><p>   //接收请求数据</p><p>    r = recv(s,&amp;msg, sizeof(msg), 0);</p><p>   close(s);</p><p>    ......</p><p> </p><p>   switch(msg.cmd) {</p><p>    casePROP_MSG_SETPROP:</p><p>       msg.name[PROP_NAME_MAX-1] = 0;</p><p>       msg.value[PROP_VALUE_MAX-1] = 0;</p><p>        /*</p><p>如果是ctl开头的消息，则认为是控制消息，控制消息用来执行一些命令，例如用</p><p>adb shell登录后，输入setprop ctl.start bootanim就可以查看开机动画了，</p><p>关闭的话就输入setpropctl.stop bootanim，是不是很有意思呢？</p><p>        */</p><p>       if(memcmp(msg.name,"ctl.",4) == 0) {</p><p>           if (check_control_perms(msg.value, cr.uid, cr.gid)) {</p><p>               handle_control_message((char*) msg.name + 4, (char*) msg.value);</p><p>           } </p><p>           ......</p><p>        }else {</p><p>           //检查客户端进程是否有足够的权限</p><p>           if (check_perms(msg.name, cr.uid, cr.gid)) {</p><p>               //然后调用property_set设置。</p><p>               property_set((char*) msg.name, (char*) msg.value);</p><p>           } </p><p>           ......</p><p>        }</p><p>       break;</p><p> </p><p>   default:</p><p>       break;</p><p>    }</p><p>}</p></div><p>当客户端的权限满足要求时，init就调用property_set进行相关处理，这个函数比较简单，代码如下所示：</p><p>[--&gt;property_service.c]</p><div><p>int property_set(const char *name, const char*value)</p><p>{</p><p>   prop_area *pa;</p><p>   prop_info *pi;</p><p> </p><p>    intnamelen = strlen(name);</p><p>    intvaluelen = strlen(value);</p><p>    ......</p><p>    //从属性存储空间中寻找是否已经存在该属性</p><p>    pi =(prop_info*) __system_property_find(name);</p><p> </p><p>if(pi!= 0) {</p><p>    //如果属性名以ro.开头，则表示是只读的，不能设置，所以直接返回。</p><p>       if(!strncmp(name, "ro.", 3)) return -1;</p><p> </p><p>        pa= __system_property_area__;</p><p>        //更新该属性的值</p><p>       update_prop_info(pi, value, valuelen);</p><p>       pa-&gt;serial++;</p><p>       __futex_wake(&amp;pa-&gt;serial, INT32_MAX);</p><p>}else {</p><p>   //如果没有找到对应的属性，则认为是增加属性，所以需要新创建一项。注意，Android支持</p><p>   //最多247项属性，如果目前属性的存储空间中已经有247项，则直接返回。</p><p>        pa= __system_property_area__;</p><p>       if(pa-&gt;count == PA_COUNT_MAX) return -1;</p><p> </p><p>        pi= pa_info_array + pa-&gt;count;</p><p>       pi-&gt;serial = (valuelen &lt;&lt; 24);</p><p>       memcpy(pi-&gt;name, name, namelen + 1);</p><p>        memcpy(pi-&gt;value, value, valuelen +1);</p><p> </p><p>       pa-&gt;toc[pa-&gt;count] =</p><p>           (namelen &lt;&lt; 24) | (((unsigned) pi) - ((unsigned) pa));</p><p> </p><p>       pa-&gt;count++;</p><p>       pa-&gt;serial++;</p><p>       __futex_wake(&amp;pa-&gt;serial, INT32_MAX);</p><p>    }</p><p>    //有一些特殊的属性需要特殊处理，这里，主要是以net.change开头的属性。</p><p>    if(strncmp("net.", name, strlen("net.")) == 0)  {</p><p>        if(strcmp("net.change", name) == 0) {</p><p>           return 0;</p><p>        }</p><p>       property_set("net.change", name);</p><p>    } elseif (persistent_properties_loaded &amp;&amp;</p><p>       strncmp("persist.", name,strlen("persist.")) == 0) {</p><p>       //如果属性名以persist.开头，则需要把这些值写到对应文件中去。</p><p>      write_persistent_property(name, value);</p><p>}</p><p>/*</p><p>还记得init.rc中的下面这句话吗？</p><p>on property:persist.service.adb.enable=1</p><p>         startadbd</p><p>当persist.service.adb.enable属性置为1后，就会执行start adbd这个command，</p><p>这是通过property_changed函数来完成的，它非常简单，读者可以自己阅读。</p><p>*/</p><p>   property_changed(name, value);</p><p>    return0;</p><p>}</p></div><p>好，属性服务端的工作已经了解了，下面看客户端是如何设置属性的。</p><h5>（3）客户端发送请求</h5><p>客户端通过property_set发送请求，property_set由libcutils库提供，代码如下所示：</p><p>[--&gt;properties.c]</p><div><p>int property_set(const char *key, const char*value)</p><p>{</p><p>   prop_msg msg;</p><p>   unsigned resp;</p><p> </p><p>   ......</p><p>   msg.cmd = PROP_MSG_SETPROP;//设置消息码为PROP_MSG_SETPROP。</p><p>   strcpy((char*) msg.name, key);</p><p>   strcpy((char*) msg.value, value);</p><p>    //发送请求</p><p>    returnsend_prop_msg(&amp;msg);</p><p>}</p><p> </p><p>static int send_prop_msg(prop_msg *msg)</p><p>{</p><p>    int s;</p><p>    int r;</p><p>    //建立和属性服务器的socket连接</p><p>    s =socket_local_client(PROP_SERVICE_NAME, </p><p>                           ANDROID_SOCKET_NAMESPACE_RESERVED,</p><p>                            SOCK_STREAM);</p><p>    if(s&lt; 0) return -1;</p><p>    //通过socket发送出去</p><p>   while((r = send(s, msg, sizeof(prop_msg), 0)) &lt; 0) {</p><p>       if((errno == EINTR) || (errno == EAGAIN)) continue;</p><p>       break;</p><p>    }</p><p> </p><p>    if(r== sizeof(prop_msg)) {</p><p>        r= 0;</p><p>    } else{</p><p>        r= -1;</p><p>    }</p><p> </p><p>   close(s);</p><p>    returnr;</p><p>}</p></div><p>至此，属性服务器就介绍完了。总体来说，还算比较简单。</p><h2>3.3  本章小结</h2><p>本章讲解了init进程如何解析zygote，以及属性服务器的工作原理，旨在帮助读者认识这个天字号第一进程。从整体来说，init.rc的解析难度相对最大。相信读者通过以上实例分析，已经理解了init.rc的解析原理。另外，inti涉及很多和Linux系统相关的知识，有兴趣的读者可以自行研究。</p> <div> <p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p> </div> </div>